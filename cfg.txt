# Keywords and operators
IF -> 'IF'
ELSE -> 'ELSE'
FOR -> 'FOR'
WHILE -> 'WHILE'
BREAK -> 'BREAK'
CONTINUE -> 'CONTINUE'
IN -> 'IN'
OF -> 'OF'
SWITCH -> 'SWITCH'
CASE -> 'CASE'
DEFAULT -> 'DEFAULT'
TRY -> 'TRY'
CATCH -> 'CATCH'
FINALLY -> 'CATCH'
FUNCTION -> 'FUNCTION'
RETURN -> 'RETURN'
RETURNVAL -> 'RETURNVAL'
THROW -> 'THROW'
VAR -> 'VAR'
LET -> 'LET'
CONST -> 'CONST'
ID -> 'ID'
NUM -> 'NUM'
STR -> 'STR'
( -> '('
( -> LT (
( -> ( LT
) -> ')'
) -> LT )
) -> ) LT
{ -> '{'
{ -> LT {
{ -> { LT
} -> '}'
} -> LT }
} -> } LT
[ -> '['
[ -> LT [
[ -> [ LT
] -> ']'
] -> LT ]
] -> ] LT
? -> '?'
? -> LT ?
? -> ? LT
: -> ':'
: -> LT :
: -> : LT
. -> '.'
. -> LT .
. -> . LT
, -> ','
, -> LT ,
, -> , LT
LT -> 'LT'
ASSIGN_OP -> 'ASSIGN_OP'
UN_OP_PRE -> 'UN_OP_PRE'
UN_OP_POS -> 'UN_OP_POS'
BIN_OP -> 'BIN_OP'

ASSIGN -> ID ASSIGN_OP OP
FUNC_CALL -> ID FUNC_ARGS
ARR -> [ COMMALIST_OP ]
ARR_ACCESS -> ID [ OP ]

# Operations
OP -> VALUE
OP -> ASSIGN
OP -> UN_OP_PRE OP
OP -> OP UN_OP_POS
OP -> OP BIN_OP OP
OP -> OP ? OP : OP
OP -> OP_PARENTHESES

VALUE -> ID
VALUE -> NUM
VALUE -> STR
VALUE -> ARR
VALUE -> FUNC_CALL
VALUE -> ARR_ACCESS
# VALUE -> VALUE . ID

# Brackets
PARENTHESES -> ( EXPR )
BRACES -> { UNBRACED_BLOCK }

OP_PARENTHESES -> ( OP )
LOOP_BRACES -> { LOOP_EXPR }
FUNC_BRACES -> { FUNC_EXPR }
FUNC_ARGS -> ( COMMALIST_ID )

# If block
B_IF -> IF OP_PARENTHESES EXPR
B_IF -> IF OP_PARENTHESES EXPR ELSE EXPR

LOOP_B_IF -> IF OP_PARENTHESES LOOP_EXPR
LOOP_B_IF -> IF OP_PARENTHESES LOOP_EXPR ELSE LOOP_EXPR

# For block
B_FOR -> FOR B_FOR_IN LOOP_EXPR
B_FOR -> FOR B_FOR_OF LOOP_EXPR

B_FOR_IN -> ( DECLARE IN OP )
B_FOR_OF -> ( DECLARE OF OP )

# While block
B_WHILE -> WHILE OP_PARENTHESES LOOP_EXPR

# Switch block
B_SWITCH -> SWITCH OP_PARENTHESES B_SWITCH_MEMBER
B_SWITCH_MEMBER -> CASE OP :
B_SWITCH_MEMBER -> CASE OP : B_SWITCH_BLOCK
B_SWITCH_MEMBER -> DEFAULT :
B_SWITCH_MEMBER -> DEFAULT : B_SWITCH_BLOCK
B_SWITCH_BLOCK -> UNBRACED_BLOCK
B_SWITCH_BLOCK -> UNBRACED_BLOCK BREAK

# Try block
B_TRY -> TRY BRACES B_CATCH
B_TRY -> TRY BRACES B_FINALLY
B_TRY -> TRY BRACES B_CATCH B_FINALLY
B_CATCH -> CATCH ( ID ) BRACES
B_CATCH -> B_CATCH B_CATCH
B_FINALLY -> FINALLY BRACES

LOOP_B_TRY -> B_TRY
LOOP_B_TRY -> TRY LOOP_BRACES LOOP_B_CATCH
LOOP_B_TRY -> TRY LOOP_BRACES LOOP_B_FINALLY
LOOP_B_TRY -> TRY LOOP_BRACES LOOP_B_CATCH LOOP_B_FINALLY
LOOP_B_CATCH -> CATCH ( ID ) LOOP_BRACES
LOOP_B_CATCH -> B_CATCH B_CATCH
LOOP_B_FINALLY -> FINALLY LOOP_BRACES

# Functions
B_FUNCTION -> FUNCTION ID FUNC_ARGS FUNC_BRACES

# Field declarations
B_DECLARE -> VAR ID
B_DECLARE -> VAR ASSIGN
B_DECLARE -> LET ID
B_DECLARE -> LET ASSIGN
B_DECLARE -> CONST ID
B_DECLARE -> CONST ASSIGN

# Throw statements
B_THROW -> THROW OP

# Expressions
EXPR -> OP LT
EXPR -> B_IF
EXPR -> B_FOR
EXPR -> B_WHILE
EXPR -> B_SWITCH
EXPR -> B_TRY
EXPR -> B_FUNCTION
EXPR -> BRACES
EXPR -> B_DECLARE
EXPR -> B_THROW
EXPR -> RETURN LT
EXPR -> RETURNVAL OP LT

LOOP_EXPR -> EXPR
LOOP_EXPR -> LOOP_B_IF
LOOP_EXPR -> LOOP_B_TRY
LOOP_EXPR -> LOOP_BRACES
LOOP_EXPR -> BREAK LT
LOOP_EXPR -> CONTINUE LT
LOOP_EXPR -> LOOP_EXPR LT
LOOP_EXPR -> LT

FUNC_EXPR -> EXPR
FUNC_EXPR -> EXPR LT
FUNC_EXPR -> LT EXPR
FUNC_EXPR -> LT

UNBRACED_BLOCK -> EXPR
UNBRACED_BLOCK -> EXPR LT
UNBRACED_BLOCK -> EXPR LT UNBRACED_BLOCK
UNBRACED_BLOCK -> LT

COMMALIST_ID -> ID
COMMALIST_ID -> COMMALIST_ID , ID
COMMALIST_OP -> OP
COMMALIST_OP -> COMMALIST_OP , OP

S -> UNBRACED_BLOCK
S -> UNBRACED_BLOCK LT
S -> LT UNBRACED_BLOCK
S -> LT UNBRACED_BLOCK LT
S -> EXPR
S -> EXPR LT
S -> EXPR LT S
S -> LT